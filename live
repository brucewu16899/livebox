#!/bin/sh
set -e

# this daemon will manage all m3u8 files
echo "[$(date)] live deamon started"

# ROOT="/home/ziyan/projects/ziyan/hsfztv/docker/edge/data/root"
ROOT="/data/root"

# number of entries to keep in m3u8
SIZE="10"

do_substream() {
    local STREAM="$1" SUBSTREAM="$2"
    local SOURCE="${ROOT}/${STREAM}/.${SUBSTREAM}.m3u8"
    local CSV="${ROOT}/${STREAM}/.${SUBSTREAM}.csv"
    local SCRATCH="${ROOT}/${STREAM}/.${SUBSTREAM}.m3u8~"
    local OUTPUT="${ROOT}/${STREAM}/${SUBSTREAM}.m3u8"

    # start the list
    [ -f "${CSV}" ] || touch "${CSV}"

    # find the latest timestamp
    local LASTTIMESTAMP="$(tail -n 1 ${CSV} | cut -d, -f1)"
    if [ -z "${LASTTIMESTAMP}" ]; then
        LASTTIMESTAMP="0"
    fi

    # compare source and list and fill missing segments
    local DURATION="0"
    cat "${SOURCE}" | while read LINE; do
        if [ "${LINE#\#EXTINF:}" != "${LINE}" ]; then
            DURATION="${LINE}"
            DURATION="${DURATION#\#EXTINF:}"
            DURATION="${DURATION%,}"
            continue
        fi
        if [ "${LINE%.ts}" != "${LINE}" ]; then
            # for segments, check if timestamp is greater then last
            local TS="${LINE}"
            local TIMESTAMP="$(echo ${TS} | cut -d. -f3)"
            if [ "${TIMESTAMP}" -gt "${LASTTIMESTAMP}" ]; then
                LASTTIMESTAMP="${TIMESTAMP}"

                # append new segment to the list
                local SESSION="$(echo ${TS} | cut -d. -f1)"
                echo "${TIMESTAMP},${SESSION},${DURATION},${TS}" >> "${CSV}"
            fi
        fi
        if [ "${LINE}" = "#EXT-X-ENDLIST" ]; then
            # TODO: stream stopped, show ads?
            :
        fi
    done

    # no point in dealing with empty list
    [ -s "${CSV}" ] || return

    # now assemble the m3u8 file
    # if total number of segment output is not changed, then we can skip
    local TOTAL="$(wc -l "${CSV}" | awk '{print $1}')"
    if [ -s "${OUTPUT}" ] && [ "$(expr `grep '^#EXT-X-MEDIA-SEQUENCE:' ${OUTPUT} | cut -d: -f2` + `grep '.ts$' ${OUTPUT} | wc -l`)" = "${TOTAL}" ]; then
        return
    fi

    # write header
    echo "#EXTM3U" > "${SCRATCH}"
    echo "#EXT-X-VERSION:3" >> "${SCRATCH}"

    # figure out duration
    local TARGETDURATION="0"
    tail -n ${SIZE} "${CSV}" | while read LINE; do
        local DURATION="$(echo ${LINE} | cut -d, -f3)"
        local ROUNDED="$(echo ${DURATION} | cut -d. -f1)"
        if [ "$(echo ${DURATION} | cut -d. -f2)" -gt "0" ]; then
            ROUNDED="$(expr 1 + ${ROUNDED})"
        fi
        if [ "${ROUNDED}" -gt "${TARGETDURATION}" ]; then
            TARGETDURATION="${ROUNDED}"
            echo "#EXT-X-TARGETDURATION:${TARGETDURATION}"
        fi
    done | tail -n 1 >> "${SCRATCH}"

    # figure out the sequence number
    local SEQUENCE="$(expr ${TOTAL} - ${SIZE})"
    if [ "${SEQUENCE}" -lt "0" ]; then
        SEQUENCE="0"
    fi
    echo "#EXT-X-MEDIA-SEQUENCE:${SEQUENCE}" >> "${SCRATCH}"

    # write each segment
    local LASTSESSION="$(tail -n `expr 1 + ${SIZE}` "${CSV}" | head -n 1 | cut -d, -f2)"
    tail -n ${SIZE} "${CSV}" | while read LINE; do
        local SESSION="$(echo ${LINE} | cut -d, -f2)"
        local DURATION="$(echo ${LINE} | cut -d, -f3)"
        local TS="$(echo ${LINE} | cut -d, -f4)"

        # if session changes, we need to inject discontinuity
        if [ "${SESSION}" != "${LASTSESSION}" ]; then
            echo "#EXT-X-DISCONTINUITY" >> "${SCRATCH}"
        fi
        LASTSESSION="${SESSION}"

        # output segment
        echo "#EXTINF:${DURATION}," >> "${SCRATCH}"
        echo "${TS}" >> "${SCRATCH}"
    done

    # publish
    mv "${SCRATCH}" "${OUTPUT}"
}

do_stream() {
    local STREAM="$1"
    find "${ROOT}/${STREAM}" -mindepth 1 -maxdepth 1 -type f -iname '.*p.m3u8' -print 2>/dev/null | for FILE in $(cat -); do
        do_substream "${STREAM}" "$(basename ${FILE} | cut -d. -f2)"
    done
}

run_once() {
    if [ ! -d "${ROOT}" ]; then
        return
    fi

    find "${ROOT}" -mindepth 1 -maxdepth 1 -type d -print 2>/dev/null | for DIR in $(cat -); do
        do_stream "$(basename ${DIR})"
    done
}

while true; do
    sleep 0.1
    run_once
done

